// 排序算法总结

// 稳定性：
// 排序算法的稳定性是指：同样大小的样本 在排序之后 不会 改变原始的 相对次序
// 每个算法都说明一下
// 稳定性对 基础类型对象 来说毫无意义；稳定性对 非基础类型对象 有意义，可以保留之前的 相对次序

// 主要算法时间、空间、稳定性总结
//              时间               空间              稳定性
//              SelectionSort    O(N^2)             O(1)               无              最呆
//              BubbleSort       O(N^2)             O(1)               有                 
//              InsertionSort    O(N^2)             O(1)               有                 
//       *      MergeSort        O(N*logN)          O(N)               有              master公式
//       *      QuickSort        O(N*logN)          O(logN)            无              按照期望来估计，最差情况没有意义
//       *      HeapSort         O(N*logN)          O(1)               无
//              CountSort        O(N)               O(M)               有
//              RadixSort        O(N)               O(M)               有

// 注意：随机快速排序的复杂度一定要按照概率上的期望指标来估计，用最差的复杂度估计无意义，随机快排讲解视频里已经有详细的说明

// 基于比较的排序，时间复杂度O(n*logn)，空间复杂度低于O(n)，还具有稳定性的排序算法目前没有找到
// TimSort也不行，虽然在实际应用中TimSort通常不需要这么多的额外空间，但空间复杂度指标就是O(n)
// 有兴趣的同学可以研究，但是在算法面试、笔试、比赛中都很少用到TimSort算法
// 同时还有希尔排序(ShellSort)也不常用，有兴趣的同学可以研究一下，就是加入步长调整的插入排序

// 所以，一切看你在排序过程中在乎什么

// 数据量非常小的情况下可以做到非常迅速：插入排序
// 性能优异、实现简单且利于改进（面对不同业务可以选择不同划分策略）、不在乎稳定性：随机快排
// 性能优异、不在乎额外空间占用、具有稳定性：归并排序
// 性能优异、额外空间占用要求O(1)、不在乎稳定性：堆排序

// 1）SelectSort（无稳定性）
//    arr[3 , 3 , 3 , 3 , 3 , 1 , 3 , 3 , 3 , 3 , 3] ----第一步----> arr[1 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3]
//        ^                   ^                            ^                   ^
//    对于 arr[0] 上的 3 来说，它与其它的 3 的相对次序已经改变了

// 2）BubbleSort（有稳定性）
//    arr[2 , 3 , 2 , 3 , 2 , 3 , 3 , 2] ----第一步----> arr[2 , 2 , 3 , 2 , 3 , 3 , 2 , 3]
//                                ^                                                  ^
//    arr[i] == arr[i+1] 时不交换
//    相同元素的相对次序没有改变

// 3）InsertionSort（有稳定性）
//    arr[1 , 2 , 3 , 4] 插入 3 ----第一步----> arr[1 , 2 , 3 , 3 , 4]
//                ^                                     ^
//    arr[i] == arr[i+1] 时不交换
//    相同元素的相对次序没有改变

// 4）MergeSort（有稳定性）
//    左：1 , 2 , 3 , 3 , 4  |  右：1 , 2 , 3 , 3 , 4 ----第一步----> 1 , 1 , 2 , 2 , 3 , 3 , 4 , 4
//        ^                        ^
//        |                        |
//        i                        j
//    当 arr[i] == arr[j] 时 优先 取 arr[i]
//    相同元素的相对次序没有改变

// 5）QuickSort（无稳定性）
//    arr[1 , 2 , 3 , 4 , 5 , 5 , 5 , 2 , 3 , 4 , 7] ----第一步----> arr[1 , 2 , 3 , 4 , 2 , 5 , 5 , 5 , 3 , 4 , 7]
//                        ^           ^           ^                                     ^           ^           ^                                                    
//                        |           |           |                                     |           |           |                                                     
//                        a           i           b                                     a           i           b  
//    swap(arr[a] , arr[i]); a++; i++;
//    交换时 arr[a] 处的 5 和其它的 5 相对位置交换了 

// 6）HeapSort（无稳定性）                         MaxHeap
//                             9                                           9
//                           /   \                                       /   \
//                          4     6         ----HeapInsert---->         6     6  
//                         /                                           /
//                        6                                           4
//  arr[9 , 4 , 6 , 6]                          arr[9 , 6 , 6 , 4]
//              |    ^                                   ^  |  
//    在 HeapInsert 和 Heapify 中 无时不刻地 在改变相对位置

// 7）CountSort & RadixSort 就是依靠稳定性所做出的排列
//    arr[17 , 11 , 13 , 17 , 19 , 17] ----第一步----> arr[11   13   17   17   17   19 ]
//        0    1    2    3    4    5                       0    1    2    3    4    5 
//        ^              #         *                                 ^    #    *


