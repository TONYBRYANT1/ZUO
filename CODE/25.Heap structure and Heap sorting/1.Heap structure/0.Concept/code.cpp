// 一、完全二叉树：
// size=14
// [a , b , c , d , e , f , g , h , i , j , k , l , m , n]
//  0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ,11 ,12 ,13
//
// 1）每一层铺完再铺下一层，每一层从左往右铺
// 2）父节点：x = (i-1)/2;   (下取整) (0除外，0的父亲是自己)
// 3）左孩子：x = i*2+1;
// 4) 右孩子：x = i*2+2;
// 5) 用 size 判断孩子是否存在
//
//                                     0:a
//
//                    1:b                                2:c
//         
//            3:d             4:e                5:f               6:g
//        
//        7:h      8:i     9:j     10:k      11:l     12:m     13:n     14:o


// 二、大根堆：所有树(子树)的最大值都在其顶部(父结点的值 >= 子结点的值)
//
// 调整（为了维护大根堆）：
// 1）HeapInsert （方向向上）
//      1）发生情况：
//          1）在大根堆末尾添加元素，元素可能大于父结点
//          2）修改大根堆某一结点，使得 修改值 大于 原值 
//      2）流程：
//          1）跟父结点比大小，进行交换
//          2）层层往上，直到小于等于父结点
//      3）复杂度：
//          1）时间复杂度：O(log2(N))   N为结点数
//              解释：结点数为 N 时，完全二叉树的高度为 log2(N)，所以最多只会进行 log2(N) 次比较
//          2）空间复杂度：O(1)
//
//
// 2）Heapify （方向向下）
//      1）发生情况：
//          1）修改大根堆某一结点，使得 修改值 小于 原值（可能导致当前结点值小于子结点的值）
//      2）流程：
//          1）比较出左右孩子中的最大值，并确定下标 best
//          2）判断当前结点的值是否小于孩子中的最大值
//          3）若小于 arr[best] 则交换，并层层往下
//          4）若大于或等于 arr[best] 则不交换，直接退出
//      3）复杂度：
//          1）时间复杂度：O(log2(N))   N为结点数
//              解释：结点数为 N 时，完全二叉树的高度为 log2(N)，所以最多只会进行 log2(N) 次比较
//          2）空间复杂度：O(1)
