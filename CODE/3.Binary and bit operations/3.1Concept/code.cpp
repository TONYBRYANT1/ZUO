// 二进制和位运算

#include<bits/stdc++.h>
using namespace std;
int main()
{
    // 1)无符号
    // int    4bytes   32bits    0~2^32-1    0~4294967296-1
    // long   8bytes   64bits    0~2^64-1

    // 2)有符号 最高位是符号位
    // int    4bytes   32bits   +有2^31个:+0~+2^31-1 -有2^31个:-2^31~-1
    // long   8bytes   64bits   +有2^63个:+0~+2^63-1 -有2^63个:-2^63~-1
    // 对于四位而言
    // 4bits -1~-8 +0~+7 --> -8~7
    // -8   -7   -6   -5   -4   -3   -2   -1   +0   +1   +2   +3   +4   +5   +6   +7
    // 1000 1001 1010 1011 1100 1101 1110 1111 0000 0001 0010 0011 0100 0101 0110 0111
    // 数字推二进制 (对于负数而言 减一取反)
    // +0 : 0000  |                                                   ^
    // +1 : 0001  |    -1 : 1111 (0001 --(-1)--> 0000 --(~)--> 1111)  |
    // +2 : 0010  |    -2 : 1110 (0010 --(-1)--> 0001 --(~)--> 1110)  |
    // +3 : 0011  |    -3 : 1101 (0011 --(-1)--> 0010 --(~)--> 1101)  |
    // +4 : 0100  |    -4 : 1100 (0100 --(-1)--> 0011 --(~)--> 1100)  |
    // +5 : 0101  |    -5 : 1011 (0101 --(-1)--> 0100 --(~)--> 1011)  |
    // +6 : 0110  |    -6 : 1010 (0110 --(-1)--> 0101 --(~)--> 1010)  |
    // +7 : 0111  |    -7 : 1001 (0111 --(-1)--> 0110 --(~)--> 1001)  |
    //            v    -8 : 1000 (1000 --(-1)--> 0111 --(~)--> 1000)  |
    // 二进制推数字 (对于负数而言 取反加一)
    // 1001 --(~)--> 0110 --(+1)--> 0111 --> -7

    // 3)进制打印
    // int a;
    // char str[100];
    // scanf("%d" , &a);
    // //十六进制输出 : 
    // printf("十六进制输出 : %x\n" , a);
    // //十进制输出 : 
    // printf("十进制输出 : %d\n" , a);
    // //八进制输出 : 
    // printf("八进制输出 : %o\n" , a);
    // //二进制输出 : 
    // itoa(a , str , 2); // 因为 printf 没有二进制对应的打印方式所以用 itoa 将a转化为二进制的字符串放在 str 中
    // printf("二进制输出 : %s\n" , str);

    // 4)进制的输入
    // // 十六进制输入 :
    // int b = 0x6f;
    // printf("十六进制输入 : 0x67 等于十进制 : %d\n" , b);
    // // 二进制输入 :
    // int a = 0b01101111; // 0b开头 后面直接写二进制表示
    // printf("二进制输入 : 0b01101111 等于十进制 : %d\n" , a);

    // 5)位运算

    // 5.1)~
    // int a;
    // char str[100];
    // scanf("%d" , &a);
    // itoa(a , str , 2);
    // printf("a的值为 : %d\n" , a);
    // printf("a的二进制 : %s\n" , str);
    // itoa(~a , str , 2);
    // printf("~a的二进制 : %s\n" , str);
    // printf("a的相反数为 : %d\n" , ~(a-1)); // 减一取反
    // printf("a的相反数为 : %d\n" , ~a+1); // 取反加一
    // //
    // // 当前单位中能表示的最小数无法通过 减一取反 或者 取反加一 来得到对应的正值
    // // 如：
    // int a;
    // char str[65];
    // a = INT_MIN;
    // itoa(a , str , 2);
    // printf("a所对应的二进制 : %s\n" , str);
    // itoa(~a+1 , str , 2);
    // printf("a的相反数所对应的二进制 : %s\n" , str);

    // 5.2)| & ^
    // int a , b;
    // a = 0b10101100;
    // b = 0b11001001;
    // char str[60];
    // itoa(a , str , 2);
    // printf("a的二进制为  :  %s\n" , str);
    // itoa(b , str , 2);
    // printf("b的二进制为  :  %s\n" , str);
    // itoa(a|b , str , 2);
    // printf("a|b的二进制为 : %s\n" , str);
    // itoa(a&b , str , 2);
    // printf("a&b的二进制为 : %s\n" , str);
    // itoa(a^b , str , 2);
    // printf("a^b的二进制为 : %s\n" , str);
    
    // 5.3)<< >>
    // int a = 0b0110;
    // char str[10];
    // itoa(a , str , 2);
    // printf("a的二进制表示    : %s     a的值%d\n" , str , a);
    // itoa(a<<1 , str , 2);
    // printf("a<<1的二进制表示 : %s     a<<1的值%d\n" , str , a<<1);
    // itoa(a<<2 , str , 2);
    // printf("a<<2的二进制表示 : %s     a<<2的值%d\n" , str , a<<2);
    // itoa(a<<3 , str , 2);
    // printf("a<<3的二进制表示 : %s     a<<3的值%d\n" , str , a<<3);
    // itoa(a>>1 , str , 2);
    // printf("a>>1的二进制表示 : %s     a>>1的值%d\n" , str , a>>1);
    // itoa(a>>2 , str , 2);
    // printf("a>>2的二进制表示 : %s     a>>2的值%d\n" , str , a>>2);
    // itoa(a>>3 , str , 2);
    // printf("a>>3的二进制表示  : %s     a>>3的值%d\n" , str , a>>3);
    
    // 5.4)二进制的打印操作
    int a = 0b11001010111;
    for(int i=31 ; i>=0 ; i--)
    {
        printf("%d " , (a & (1<<i)) == 0 ? 0 : 1); // 对于普通的 1 最多只能移动 31位 否则要用 long 类型的 1
    }
    return 0;
}





